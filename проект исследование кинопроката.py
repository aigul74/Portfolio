#!/usr/bin/env python
# coding: utf-8

# <div class="alert alert-success">
# <b> Комментарий от ревьюера 3 ✔️</b>
# 
# Привет! Оформление комментариев по работе сохраняется. Только обозначим, что это третья итерация. 
# 
# </div>

# <div class="alert alert-success">
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# Привет еще раз. Оформление комментариев по работе сохраняется. Только обозначим, что это вторая итерация. 
# 
# </div>

# ## <b>Комментарий от ревьюера</b>
# 
# Привет! Меня зовут Ярослав, я буду делать ревью твоего проекта. Давай будем общаться на «ты».
# 
# Мои комментарии будут в ячейках "Комментарий от ревьюера".
# 
# <div class="alert alert-danger"> 
# 
# <b> Комментарий от ревьюера ❗</b>
# 
# Красным цветом обозначены комментарии, на которые тебе нужно обратить внимание в первую очередь, чтобы я принял проект. 
# </div>
# <div class="alert alert-warning">
# 
# <b> Комментарий от ревьюера ⚠️</b>
# 
# Желтым цветом отмечено то, что ты можешь сделать немного по-другому. Ты можешь учесть эти комментарии при выполнении следующих проектов.
# </div>
# <div class="alert alert-success">
# 
# <b> Комментарий от ревьюера ✔️</b>
# 
# Зелёным цветом обозначены твои удачные решения, которые ты без сомнения можешь применять в будущих проектах.  
# </div>
# 
# Если ты вносишь изменения в проект по моим рекомендациям, указывай, пожалуйста, это в своих комментариях. Будет удобно, если обозначишь свои комментарии заметным цветом или поместишь 
# 
# <div class="alert alert-info">
#     
# в такую ячейку
# </div>
# 
# Давай при работе с проектом мы будем общаться с тобой в диалоге, поэтому не удаляй и не перемещай мои комментарии, это поможет мне сделать повторную  проверку проекта быстрее.
# ___
# 

# <h1>Содержание<span class="tocSkip"></span></h1>
# <div class="toc"><ul class="toc-item"><li><span><a href="#Комментарий-от-ревьюера" data-toc-modified-id="Комментарий-от-ревьюера-1"><span class="toc-item-num">1&nbsp;&nbsp;</span><b>Комментарий от ревьюера</b></a></span></li><li><span><a href="#Исследование-данных-о-российском-кинопрокате" data-toc-modified-id="Исследование-данных-о-российском-кинопрокате-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Исследование данных о российском кинопрокате</a></span><ul class="toc-item"><li><span><a href="#Шаг-1.-Откройте-файлы-с-данными-и-объедините-их-в-один-датафрейм." data-toc-modified-id="Шаг-1.-Откройте-файлы-с-данными-и-объедините-их-в-один-датафрейм.-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>Шаг 1. Откройте файлы с данными и объедините их в один датафрейм.</a></span></li><li><span><a href="#Шаг-2.-Предобработка-данных" data-toc-modified-id="Шаг-2.-Предобработка-данных-2.2"><span class="toc-item-num">2.2&nbsp;&nbsp;</span>Шаг 2. Предобработка данных</a></span><ul class="toc-item"><li><span><a href="#Шаг-2.1.-Проверьте-типы-данных" data-toc-modified-id="Шаг-2.1.-Проверьте-типы-данных-2.2.1"><span class="toc-item-num">2.2.1&nbsp;&nbsp;</span>Шаг 2.1. Проверьте типы данных</a></span></li><li><span><a href="#Шаг-2.2.-Изучите-пропуски-в-датафрейме" data-toc-modified-id="Шаг-2.2.-Изучите-пропуски-в-датафрейме-2.2.2"><span class="toc-item-num">2.2.2&nbsp;&nbsp;</span>Шаг 2.2. Изучите пропуски в датафрейме</a></span></li><li><span><a href="#Шаг-2.3.-Изучите-дубликаты-в-датафрейме" data-toc-modified-id="Шаг-2.3.-Изучите-дубликаты-в-датафрейме-2.2.3"><span class="toc-item-num">2.2.3&nbsp;&nbsp;</span>Шаг 2.3. Изучите дубликаты в датафрейме</a></span></li><li><span><a href="#Шаг-2.4.-Изучите-категориальные-значения" data-toc-modified-id="Шаг-2.4.-Изучите-категориальные-значения-2.2.4"><span class="toc-item-num">2.2.4&nbsp;&nbsp;</span>Шаг 2.4. Изучите категориальные значения</a></span></li><li><span><a href="#Шаг-2.5.-Проверьте-количественные-значения" data-toc-modified-id="Шаг-2.5.-Проверьте-количественные-значения-2.2.5"><span class="toc-item-num">2.2.5&nbsp;&nbsp;</span>Шаг 2.5. Проверьте количественные значения</a></span></li><li><span><a href="#Шаг-2.6.-Добавьте-новые-столбцы" data-toc-modified-id="Шаг-2.6.-Добавьте-новые-столбцы-2.2.6"><span class="toc-item-num">2.2.6&nbsp;&nbsp;</span>Шаг 2.6. Добавьте новые столбцы</a></span></li></ul></li><li><span><a href="#Шаг-3.-Проведите-исследовательский-анализ-данных" data-toc-modified-id="Шаг-3.-Проведите-исследовательский-анализ-данных-2.3"><span class="toc-item-num">2.3&nbsp;&nbsp;</span>Шаг 3. Проведите исследовательский анализ данных</a></span></li><li><span><a href="#Шаг-4.-Исследуйте-фильмы,-которые-получили-государственную-поддержку" data-toc-modified-id="Шаг-4.-Исследуйте-фильмы,-которые-получили-государственную-поддержку-2.4"><span class="toc-item-num">2.4&nbsp;&nbsp;</span>Шаг 4. Исследуйте фильмы, которые получили государственную поддержку</a></span></li><li><span><a href="#Шаг-5.-Общий-вывод." data-toc-modified-id="Шаг-5.-Общий-вывод.-2.5"><span class="toc-item-num">2.5&nbsp;&nbsp;</span>Шаг 5. Общий вывод.</a></span></li></ul></li></ul></div>

# ## Исследование данных о российском кинопрокате
# 
# 

# <div class="alert alert-warning">
#     
# <b> Комментарий от ревьюера ⚠️</b>
#     
# В начале работы стоит добавить описание проекта, чтобы твои коллеги понимали цели исследования. Это поможет и тебе, если ты вернешься к проекту спустя время.
#     
# Еще сюда можно добавить описание данных и оглавление. Описание поможет быстрее разобраться, что у нас лежит в датафрейме, а оглавление позволит понять охваченные вопросы и поможет сразу перейти к нужному разделу.
# </div>

# <div class="alert alert-info">
#     
# **Описание проекта**
# 
# Заказчик этого исследования — Министерство культуры Российской Федерации.
# Вам нужно изучить рынок российского кинопроката и выявить текущие тренды. Уделите внимание фильмам, 
# которые получили государственную поддержку. Попробуйте ответить на вопрос, насколько такие фильмы 
# интересны зрителю.
# Вы будете работать с данными, опубликованными на портале открытых данных Министерства культуры. 
# Набор данных содержит информацию о прокатных удостоверениях, сборах и государственной поддержке 
# фильмов, а также информацию с сайта КиноПоиск.
#     
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# Здорово, что указала цель исследования
# 
# </div>
# 

# ### Шаг 1. Откройте файлы с данными и объедините их в один датафрейм. 
# 
# Объедините данные таким образом, чтобы все объекты из датасета `mkrf_movies` обязательно вошли в получившийся датафрейм. 
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_0" aria-expanded="false" aria-controls="collapseHint_0">Подсказка</button>
#         </div>
#         <div id="collapseHint_0" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# Обратите внимание на тип данных столбца, по которому будете соединять датафреймы. Тип данных этих столбцов должен быть одинаковым в обоих датафреймах.
#             </div>
#         </div>
#     </div>
# </div>

# In[1]:


#импорт библиотек
import pandas as pd
import numpy as np
import seaborn as sns

import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
import matplotlib
plt.style.use('ggplot')
from matplotlib.pyplot import figure
get_ipython().run_line_magic('matplotlib', 'inline')
matplotlib.rcParams['figure.figsize'] = (12,8)

pd.options.mode.chained_assignment = None


# In[2]:


#вывели на экран таблицу с данными
df_movies = pd.read_csv('/datasets/mkrf_movies.csv')
from IPython.display import display
display(df_movies.head()) 


# In[3]:


#выводим на экран данные из второго df
df_shows = pd.read_csv('/datasets/mkrf_shows.csv')
from IPython.display import display
display(df_shows.head())


# In[4]:


df_movies.info()
df_shows.info()


# In[5]:


df_movies[~df_movies['puNumber'].str.isdigit()]


# In[6]:


df_movies.loc[804, 'puNumber'] = df_movies.loc[804, 'puNumber'].strip()
df_movies.loc[1797, 'puNumber'] = '0'


# In[7]:


#Поменяли тип данных, и заменили пропуск на NaN
df_movies['puNumber'] = pd.to_numeric(df_movies['puNumber'])
#Выводим тип данных 
df_movies['puNumber'].dtype


# In[8]:


#обьединили две таблицы в одну по столбцу 'puNumber' с переносом всех строк из df_movies
df = df_movies.merge(df_shows, on='puNumber', how='left')


# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# С объединением данных все отлично!
# 
# </div>

# ### Шаг 2. Предобработка данных

# #### Шаг 2.1. Проверьте типы данных
# 
# - Проверьте типы данных в датафрейме и преобразуйте их там, где это необходимо.

# In[9]:


#Вывели на экран информацию о типах данных общей таблицы
df.info()
#поменяли неправильный тип обьект на тип формата времени.
df['show_start_date'] = pd.to_datetime(df['show_start_date'], format='%Y-%m-%dT%H:%M:%S')
df['show_start_date'].dtype


# In[10]:


#Вывели список уникальных значений
df['ratings'].unique()


# In[11]:


#Присвоили переменную с значением таблицы где рейтинг указан в процентах
prosent_raitings = df[df['ratings'].str.contains('[^0-9.]').fillna(False)]
prosent_raitings


# In[12]:


#Привели проценты в десятичные части
df.loc[prosent_raitings.index, 'ratings'] = prosent_raitings['ratings'].str[0] + '.' + prosent_raitings['ratings'].str[1]
#Поменяли тип данных
df['ratings'] = pd.to_numeric(df['ratings']) 
df['ratings'].dtype


# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# С типами данных все отлично!
# 
# </div>

# #### Шаг 2.2. Изучите пропуски в датафрейме
# 
# - Объясните, почему заполнили пропуски определённым образом или почему не стали этого делать.

# In[13]:


df.isna().sum()


# In[14]:


def pass_charts(df):
    try:
        (
            (df.isna().mean()*100)
            .to_frame()
            .rename(columns = {0:'space'})
            .query('space > 0')
            .sort_values(by = 'space', ascending = True)
            .plot(kind= 'barh', figsize=(19,6), rot = -5, legend = False, fontsize = 16)
            .set_title('Пример' + "n", fontsize = 22, color = 'SteelBlue')    
        );    
    except:
        print('пропусков не осталось :) ')


# In[15]:


pass_charts(df)


# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# Проще всего читать горизонтальный текст, поэтому лучше убрать наклон у подписей по оси Y
# </div>

# In[16]:


#Присваиваем переменную со значением пропусков df
df_charts = df.isna()
#Создаем матрицу распределения пропусков по годам
df_charts['year'] = df['show_start_date'].dt.year
df_charts['total_records'] = True
df_charts.groupby(by='year').agg(sum).transpose()


# **Вывод:**
# - Количество пропусков в колонках *refundable_support*, *nonrefundable_support*, *budget*, *financing_source* совпадают.
# - Количество пропусков не зависит от года, примерное одинаковое распределение по времени.

# In[17]:


#Создали переменную для выведения таблицы по пропускам в России

tmp = df.budget.isna().rename('is_na').to_frame()
tmp['is_rus'] = df.production_country.str.contains('Россия')
display(tmp.groupby(['is_na']).agg(['sum', 'count']).set_axis(['Россия', 'Всего'], axis=1))

del tmp


# - Информация по государственной поддержке есть только по российским фильмам, но у большинства 
# фильмов нет информации о господдержке. 
# - Возможно большинство российских фильмов снималось без господдержки.

# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# Так что делать с пропусками? Почему мы их решили не заполнять? Прокомментируй, пожалуйста. 
# </div>

# <div class="alert alert-info">
# 
# **Вывод:**
# - Оставим пропуски в остальных колонках как есть, некоторые колонки содержат 
# нули как значение и заменяя пропуски на нули можно смешать действительные
# значения на замененные.
# - Поменяю если пропуски будут мешать при обработке данных.
# 
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# 👍
# 
# </div>
# 

# #### Шаг 2.3. Изучите дубликаты в датафрейме
# - Проверьте, есть ли в данных дубликаты. Опишите причины, которые могли повлиять на появление дублей.

# In[18]:


print('Количество дублирующихся строк:', df.duplicated().sum())

df.nunique()


# In[19]:


#Выводим на экран последние строки колонки страны
df['production_country'].tail()


# In[20]:


#Редактируем пробел, приводим к эдиным знакам препинания
df['production_country'] = df['production_country'].dropna().apply(lambda x: ', '.join([x.strip()
for x in x.split('-')]))
df['production_country'].tail()


# <div class="alert alert-warning">
#     
# <b> Комментарий от ревьюера ⚠️</b>
#     
# Мы же вроде в прошлом разделе с пропусками работали. Давай перенесем код туда, чтобы не ломать структуру проекта
# </div>

# <div class="alert alert-info">
#     
# Не стала менять т.к. не мешает.
# 
# </div>
# 

# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# 1. Давай не менять признак genre, дальше ведь мы все равно будем основной жанр в отдельный признак
# 1. Используй, пожалуйста, метод [str.split](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.split.html) вместо replace, чтобы не создавать кучу словарей.
# 1. Проверь, пожалуйста, дубликаты в нашей таблице. Судя по описанию уникальные значения могут содержаться в title и puNumber
# </div>

# In[21]:


df.loc[df['title'].duplicated(keep=False)].sort_values(by='title').tail()   


# - Повторы в *title* возможны из-за того фильмы могут выходить в разные даты и под разными лицензиями.
# - Дубликат в фмльме *Ян Антонышев* вышели в одну дату но ноиер лицензии отличается возможно ошибка 
# заполнения как человеческий фактор.

# In[22]:


df.loc[df['puNumber'].duplicated(keep=False)]


# - Разные фильмы под одним номером лицензии ошибка в запонении
# - Фильм 5067 и 5068 при одной лицензии отличаются в названии, стране и директоре опечатка и 
# не точность в заполнии человеческий фактор

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# С поиском дубликатов все замечательно!
# 
# </div>

# #### Шаг 2.4. Изучите категориальные значения
# 
# - Посмотрите, какая общая проблема встречается почти во всех категориальных столбцах;
# - Исправьте проблемные значения в поле `type`.
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_1" aria-expanded="false" aria-controls="collapseHint_1">Подсказка</button>
#         </div>
#         <div id="collapseHint_1" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# В поле <code>type</code> есть несколько значений, у которых появился пробел в начале строки. Самый простой способ их «починить» -- использовать метод <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.str.strip.html#pandas.Series.str.strip">.str.strip</a>. Этот метод удаляет все пробелы, которые встречаются в начале и в конце строки. Применяют его таким образом:<br>
# <code>df['type'].str.strip()</code>
#             </div>
#         </div>
#     </div>
# </div>

# In[23]:


#Вывела список уникальных значений колонки
sorted(df['type'].unique())


# In[24]:


#Удаляем пробелы в начале строк
df['type'] = df['type'].str.strip()
sorted(df['type'].unique())


# In[25]:


#Проверяем на ошибки список уникальных значений
df['age_restriction'].unique()


# In[26]:


#Проверяем на ошибки список уникальных значений
df['financing_source'].unique()


# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# Подскажи, какая общая проблема встречается в категориальных признаках?
# </div>

# <div class="alert alert-info">
#     
# **Вывод:**
# - Общая проблема в категориальных признаках лишние пробелы, разная пунктуация
# 
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# Верно. Еще к проблемам можно отнести большое количество уникальных значений в категориальных признаках (мы столкнулись с этой проблемой на прошлой итерации, когда обрабатывали признак genre)
# </div>

# #### Шаг 2.5. Проверьте количественные значения
# 
# - Проверьте, обнаружились ли в таких столбцах подозрительные данные. Как с такими данными лучше поступить?
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_budget" aria-expanded="false" aria-controls="collapseHint_budget">Подсказка</button>
#         </div>
#         <div id="collapseHint_budget" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# Обратите внимание на описание столбца <code>budget</code>. Как этот столбец соотносится с двумя другими: <code>refundable_support</code> и <code>nonrefundable_support</code>?
#             </div>
#         </div>
#     </div>
# </div>

# In[27]:


#Выводим таблицу с аномальными значениями 'budget'
invalid_budget = df[df['budget'] < (df['refundable_support'] + df['nonrefundable_support'])]
invalid_budget


# In[28]:


#Создаем диаграмму рассеяния зависимости бюджета от господдержки
ax = df.plot.scatter(
    title='Зависимость размера бюджета от объёма господдержки',
    label='объём возвратных средств',
    x='budget',
    y='refundable_support',
    color='blue',
    alpha=0.3
)

df.plot.scatter(
    label='объём невозвратных средств',
    x='budget', y='nonrefundable_support',
    color='green',
    alpha=0.3,
    ax=ax)
#Вычисляем долю участия в бюжете государства
df['support_percentage'] = (df['refundable_support'] + df['nonrefundable_support']) / df['budget']
support_percentage = df['support_percentage'].median()

print('Чаще всего доля участия государства в бюджете составляет', support_percentage)
print()


# In[29]:


df.loc[invalid_budget.index, 'budget'] = (df.loc[invalid_budget.index, 'refundable_support'] + df.loc[invalid_budget.index, 'nonrefundable_support']) / support_percentage

df.loc[invalid_budget.index]


# - Есть ряд фильмов, которые получали господдержку, но в бюджете стоит 0. 
# - Чаще всего доля участия государства в бюджете составляет 0.613.

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# Здорово, что обратила внимание на ошибку в budget
# 
# </div>

# #### Шаг 2.6. Добавьте новые столбцы
# 
# 
# 
# 

# - Создайте столбец с информацией о годе проката. Выделите год из даты премьеры фильма.

# In[30]:


#Создали колонку с годом проката
df['year'] = df['show_start_date'].dt.year


# In[31]:


df.head()


# - Создайте два столбца: с именем и фамилией главного режиссёра и основным жанром фильма. В столбцы войдут первые значения из списка режиссёров и жанров соответственно.
# 
# <div id="accordion">
#     <div class="card">
#         <div class="card-header" id="headingThree">
#             <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseHint_2" aria-expanded="false" aria-controls="collapseHint_2">Подсказка</button>
#         </div>
#         <div id="collapseHint_2" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
#             <div class="card-body">
# Чтобы создать такие столбцы, лучше всего использовать собственную функцию. Эту функцию можно применить к двум столбцам сразу. 
#             </div>
#         </div>
#     </div>
# </div>

# In[32]:


#Создали функцию для вывода двух новых колонок 
def add_main(df, columns):
    for column in columns:
        df[f'main_{column}'] = df[column].dropna().apply(lambda x: x.split(',')[0])
    return df


# In[33]:


#перезаписали наш df
df = add_main(df, ['director', 'genres', 'production_country'])
df.head()


# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# Прокомментируй, пожалуйста, чем сейчас main_genre отличается от genre
# </div>

# <div class="alert alert-info">
#     
# - В main_genre вошло только первое значение из списка genre.
# 
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# 👍
# </div>

# - Посчитайте, какую долю от общего бюджета фильма составляет государственная поддержка.

# In[34]:


# Вычислили долю участия государства в бюджете фильма
df['support_percentage'] = (df['refundable_support'] + df['nonrefundable_support']) / df['budget']
support_percentage = df['support_percentage'].median()

print('Чаще всего доля участия государства в бюджете составляет', support_percentage)
print()


# - Среднее значение участия государства в бюджете фильма 0,613.

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# С добавлением признаков все хорошо
# 
# </div>

# ### Шаг 3. Проведите исследовательский анализ данных
# 

# - Посмотрите, сколько фильмов выходило в прокат каждый год. Обратите внимание, что данные о прокате в кинотеатрах известны не для всех фильмов. Посчитайте, какую долю составляют фильмы с указанной информацией о прокате в кинотеатрах.

# In[35]:


#Присвайваем переменной значение 'box_office' без пропусков по годам
df_pivot = df.loc[df['box_office'].notna(), ['year', 'box_office']]                 .groupby('year')                 .agg(['count', 'sum', 'mean', 'median'])

df_pivot.columns = df_pivot.columns.get_level_values(1)


# In[36]:


#Строим диаграмму для переменной df_pivot
df_pivot.plot(title='количество фильмов в прокате по годам', kind='bar', y='count')
print(f'Доля фильмов, для которых есть информация о прокате: {df.box_office.notna().mean():.2f}')


# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# Посчитай, пожалуйста, долю фильмов с информацией о прокате в разрезе лет, как нас просят в задании. Это позволит сделать вывод о полноте данных.
# </div>
# 

# <div class="alert alert-info">
#     
# Не поняла комментарий выше, я же вроде вывела и диаграмму количества проката по годам.
# И долю пропусков посчитала 0,42.
#     
# </div>

# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера 2 ❗</b>
#     
# Сейчас мы смотрим на диаграмме на количество фильмов, у которых были сборы, в разрезе лет. Давай еще построим такой же график, но с долей фильмов в прокате
#     
# Например, в 2010 в прокате было только 10% фильмов, а в 2019 - 57%. Нужно посмотреть всю эту динамику и определить какой период полнее всего представлен в данных
#     
# `df.query('year==2010').box_office.notna().mean()`  
# `df.query('year==2019').box_office.notna().mean()`    
# 
# </div>

# In[37]:


#Вывели график доли проката по годам
df['share'] = df['box_office'].notna()
df.query('year >=2010 and year <= 2019')        .pivot_table(index='year', values='share', aggfunc='mean')        .plot(title='Доля фильмов в прокате по годам', kind='bar');


# <div class="alert alert-warning">
#     
# <b> Комментарий от ревьюера 3 ⚠️</b>
#     
# График замечательный, только вывода не хватает! Тут можно предположить, что до 2015 года данные неполные, потому что в 2015 происходит резкий рост доли фильмов в прокате.    
#     
# </div>

# - Изучите, как менялась динамика проката по годам. В каком году сумма сборов была минимальной? А максимальной?

# In[38]:


#Строим график зависимости сбора по годам

df_pivot.plot(title='сборы фильмов в прокате по годам', kind='line', y='sum')
print(f"В {df_pivot['sum'].idxmin()} году сумма сборов была минимальной, в {df_pivot['sum'].idxmax()} максимальной.")


# - С помощью сводной таблицы посчитайте среднюю и медианную сумму сборов для каждого года.

# In[39]:


#Выведи график зависимости срелней и медианы сборов по годам
df_pivot.plot(title='средняя и медианная сумма сборов по годам', kind='line', y=['median', 'mean'])
print()


# - Определите, влияет ли возрастное ограничение аудитории («6+», «12+», «16+», «18+» и т. д.) на сборы фильма в прокате в период с 2015 по 2019 год? Фильмы с каким возрастным ограничением собрали больше всего денег в прокате? Меняется ли картина в зависимости от года? Если да, предположите, с чем это может быть связано.

# In[40]:


#Вывели график зависимости сбора от возрастных категории и года
df[df['box_office'].notna()]     .pivot_table(index='year',
                columns='age_restriction',
                values='box_office',
                aggfunc='sum') \
    .plot(title='сумма сборов по годам с разбивкой по возрастным категориям', kind='line', xlim=[2015, 2019])
print()


# In[41]:


df[['box_office', 'age_restriction']].groupby('age_restriction')                                         .agg('median')                                         .sort_values(by='box_office', ascending=False)                                         .plot(title='Медианный прокат фильмов по категориям', kind='bar');


# <div class="alert alert-warning">
#     
# <b> Комментарий от ревьюера ⚠️</b>
#     
# Здорово, что посмотрела на суммарные сборы. Давай еще посчитаем количество фильмов в каждой категории и медианные сборы. Сейчас нельзя понять, с чем связаны большие суммарные сборы в категории 16+: с популярностью фильмов или их большим количеством
# </div>

# **Вывод:**
# - Доля фильмов, для которых есть информация о сборах: 0.42.
# - Больше всего фильмов вышло в 2016 и 2019 года.
# - Минимальные суммы сборов с 2010 по 2013 года.
# - Максимальные в 2018 году.
# - Средние значения начиная с 2013 года очень сильно выросли пика достигли в 2017г.
# - Медианные же значения не сильно изменились
# - Можно предположить что фильмы стали собирать больше сборов
# - Больше всего сборов 16+
# - По годам 16+ в 2017г и 12+ в 2018г.
# - Возможно причина в том что 2017 году вышли несколько культовых продолжений популярных фильмов 
# например *Звездные войны*, *Форсаж8*.
# - По количеству в 2017 году вышло меньше фильмов в прокат, но по средним сборам 2017 год это максимум,
# значит был повышенный интерес возраста 16+ высокобюджетный со спецэфектами.

# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# Выводы правильные, все замечательно, но используй, пожалуйста, тип ячейки Markdown
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# 👍
# </div>

# ### Шаг 4. Исследуйте фильмы, которые получили государственную поддержку
# 
# На этом этапе нет конкретных инструкций и заданий — поищите интересные закономерности в данных. Посмотрите, сколько выделяют средств на поддержку кино. Проверьте, хорошо ли окупаются такие фильмы, какой у них рейтинг.

# In[42]:


#Присваиваем переменой список без пропусков из из колонок возмещаемая и невозмещаемая поддержка
df_supported = df[(df['refundable_support'].notna() | df['nonrefundable_support'].notna()) & 
                  (df['year'] > 2014)]
#Создаем список из сумм возмещаемая и невозмещаемая поддержка
df_supported['full_support'] = df_supported['nonrefundable_support'] + df_supported['refundable_support']
#Создаем список рентабельность как деление колнки сборов на колонку полной поддержки с вычетом единицы  
df_supported['profitability'] = df_supported['box_office'] / df_supported['full_support'] - 1
#Создаем список окупается в которую включены все положительные значения рентабельности
df_supported['is_paid_off'] = df_supported['profitability'] > 0
 #Создаем список не окупилось со значением всех остальных по рентабельности
df_supported['is_not_paid_off'] = ~df_supported['is_paid_off']


# In[43]:


#Создаем диаграмму среднего рейтинга по жанрам
df_supported[['main_genres', 'ratings']].groupby('main_genres')                                         .agg('mean')                                         .sort_values(by='ratings', ascending=False)                                         .plot(title='средняя оценка фильмов по жанрам', kind='bar')


# In[44]:


df_supported[['box_office', 'main_genres']].groupby('main_genres')                                         .agg('sum')                                         .sort_values(by='box_office', ascending=False)                                         .plot(title=' Прокат фильмов по жанрам', kind='bar');


# In[45]:


#Посчитали господержку по жанпрам
df_supported['main_genres'].value_counts().plot(title='количество фильмов, получивших господдержку (по жанрам)', kind='bar');


# In[46]:


#Выводим диаграмму рентабельности по жанрам
df_supported.groupby('main_genres')             .agg({'title':'count', 
                  'is_paid_off':'sum',
                  'is_not_paid_off':lambda x: 0 - x.sum()}) \
            .sort_values(by='title',
                         ascending=False) \
            .plot(title='количество окупившихся и не окупившихся фильмов',
                   kind='bar',
                   stacked=True,
                   y=['is_paid_off', 'is_not_paid_off']);


# In[47]:


# посчитали стоимость поддержки по жанрам
df_supported.groupby('main_genres')             .agg('sum')             .sort_values(by='full_support',
                         ascending=False) \
            .plot(title='объём государственной поддержки',
                  kind='bar',
                  stacked=True,
                  y=['refundable_support', 'nonrefundable_support']);


# In[48]:


# рентабельность по жанрам
df_supported.groupby('main_genres')             .agg('sum')             .sort_values(by='full_support',
                         ascending=False) \
            .plot(title='общая рентабельность жанра c 2015 по 2019',
                  kind='bar',
                  stacked=True,
                  y='profitability');


# In[49]:


#вывели диаграмму средней рентабельности по жанрам
df_supported.groupby('main_genres')             .agg('mean')             .sort_values(by='profitability',
                         ascending=False) \
            .plot(title='средняя рентабельность фильма (по жанрам) с 2015 по 2019',
                  kind='bar',
                  stacked=True,
                  y='profitability');


# - В российском прокате доля финансирования государства состовляет примерно 60 %.
# - Самые высокие рейтинги у жанра *Криминал* потом *Детский*.
# - Больше всего фильмов получают господдержку в жанре *Драма*, затем *Комедия*. 
# - Самый не рентабельный убыточный жанр *Драма* .
# - По жанру *Комедия* саммые высокие показатели среди всех жанров но и господдержки тоже не мало
# но в итоге поддержка не окупается.
# - Не плохие показатели окупаемости фильмов жанра *Мультфильм* при меньшей господдержке.
# - Самая высокая рентабельность у жанров *Комедия* затем *Мульфильм*.
# - Средняя рентабельность по жанрам самая высокая у *Биография* потом *Приключения*, самая низкая 
# у жанра *Детский*.
# - Господдерка жанра *Драма* не оправданна, этот жанр не популярен ни по рейтингам, ни по рентабельности.
# - Возможно стоило бы применить бюджетные деньги в более популярные и рентабельные жанры и меньшими
# ресурсами получить более положительный эффект

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# У тебя получилось интересное исследование!
#     
# Только обрати внимание, что в прошлом разделе мы заметили, что данные по сборам до 2015 года могут быть неполными, поэтому тут в расчетах, связанных с деньгами/рентабельность/т.д., лучше использовать информацию начиная с 2015 года, чтобы не было искажений.
#     
# В плане средней оценки жанров, было бы интересно сравнить результаты с фильмами без гос.поддержки.
# 
# </div>

# ### Шаг 5. Общий вывод.

# - При не большом количестве фильмов жанра *Криминал*, рейтиг самый высокий.
# - Фильмы, которые получили государственную поддержку имеют невысокий рейтинг,
# возможно в сравненни уступают зарубежным.  
# - На жанр *Комедия и *Мультфилмы* зритель еще ходит то *Драма* совсем не интересна.

# <div class="alert alert-danger">
#     
# <b> Комментарий от ревьюера ❗</b>
#     
# Это хороший вывод, но он относится к последнему разделу про анализ фильмов с гос.поддержкой. 
#     
# Перенеси его туда, пожалуйста, и добавь общий вывод по работе. В общий вывод можно добавить краткое описание работы, отметить интересные особенности и ответить на основной вопрос исследования.
# </div>

# <div class="alert alert-warning">
#     
# <b> Комментарий от ревьюера 2 ⚠️</b>
#     
# В выводе не отражены результаты исследования в разделе "Шаг 3. Проведите исследовательский анализ данных"
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера ✔️</b>
#     
# Спасибо за твою работу! Ты хорошо справилась с подготовкой и анализом данных.
#     
# Осталось немного дополнить проект:
#     
# - прокомментировать обработку пропусков
# - проверить дубликаты в таблице
# - определить общую проблему в категориальных признаках
# - определить долю фильмов в прокате в разрезе лет
# - добавить общий вывод
# 
# Задавай вопросы к моим комментариям, если есть. Жду твои исправления :)
# </div>

# <div class="alert alert-success">
#     
# <b> Комментарий от ревьюера 2 ✔️</b>
# 
# Осталось сделать совсем чуть-чуть:
#     
# - определить долю фильмов в прокате в разрезе лет
#     
# Жду твои исправления
#     
# </div>

# <div class="alert alert-success">
# <b> Комментарий от ревьюера 3 ✔️</b>
# 
# Спасибо, что учла мои комментарии. Надеюсь, эта работа была полезна для тебя. Я принимаю проект и желаю удачи в прохождении курса!
# 
# </div>
# 

# 

# 

# In[ ]:




